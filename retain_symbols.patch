From 0ee12e411593e092f76020da6bcdae5e651246ac Mon Sep 17 00:00:00 2001
From: Rui Ueyama <ruiu@cs.stanford.edu>
Date: Sat, 21 Sep 2024 16:41:17 +0900
Subject: [PATCH] Do not strip linker-synthesized symbols when
 --retain-symbols-file is given

This is an attempt to fix https://github.com/rui314/mold/issues/1346
---
 src/cmdline.cc              | 7 ++++---
 src/input-files.cc          | 6 ------
 src/main.cc                 | 7 ++++---
 src/mold.h                  | 2 +-
 src/output-chunks.cc        | 4 ++--
 src/passes.cc               | 8 +++-----
 test/retain-symbols-file.sh | 8 ++++----
 7 files changed, 18 insertions(+), 24 deletions(-)

diff --git a/elf/cmdline.cc b/elf/cmdline.cc
index efb09d884a..6d10875a88 100644
--- a/elf/cmdline.cc
+++ b/elf/cmdline.cc
@@ -438,8 +438,7 @@ template <typename E>
 static void read_retain_symbols_file(Context<E> &ctx, std::string_view path) {
   MappedFile *mf = must_open_file(ctx, std::string(path));
   std::string_view data((char *)mf->data, mf->size);
-
-  ctx.arg.retain_symbols_file.reset(new std::unordered_set<std::string_view>);
+  std::vector<Symbol<E> *> vec;
 
   while (!data.empty()) {
     size_t pos = data.find('\n');
@@ -455,8 +454,10 @@ static void read_retain_symbols_file(Context<E> &ctx, std::string_view path) {
 
     name = string_trim(name);
     if (!name.empty())
-      ctx.arg.retain_symbols_file->insert(name);
+      vec.push_back(get_symbol(ctx, name));
   }
+
+  ctx.arg.retain_symbols_file = std::move(vec);
 }
 
 static bool is_file(std::string_view path) {
diff --git a/elf/input-files.cc b/elf/input-files.cc
index e07ae1d63d..afe1fc1ec2 100644
--- a/elf/input-files.cc
+++ b/elf/input-files.cc
@@ -1103,9 +1103,6 @@ static bool should_write_to_local_symtab(Context<E> &ctx, Symbol<E> &sym) {
 
 template <typename E>
 void ObjectFile<E>::compute_symtab_size(Context<E> &ctx) {
-  if (ctx.arg.strip_all)
-    return;
-
   this->output_sym_indices.resize(this->elf_syms.size(), -1);
 
   auto is_alive = [&](Symbol<E> &sym) -> bool {
@@ -1449,9 +1446,6 @@ bool SharedFile<E>::is_readonly(Symbol<E> *sym) {
 
 template <typename E>
 void SharedFile<E>::compute_symtab_size(Context<E> &ctx) {
-  if (ctx.arg.strip_all)
-    return;
-
   this->output_sym_indices.resize(this->elf_syms.size(), -1);
 
   // Compute the size of global symbols.
diff --git a/elf/main.cc b/elf/main.cc
index 3d94173926..8e7d45721a 100644
--- a/elf/main.cc
+++ b/elf/main.cc
@@ -392,8 +392,8 @@ int mold_main(int argc, char **argv) {
 
   // Handle --retain-symbols-file options if any.
   if (ctx.arg.retain_symbols_file)
-    for (std::string_view name : *ctx.arg.retain_symbols_file)
-      get_symbol(ctx, name)->write_to_symtab = true;
+    for (Symbol<E> *sym : *ctx.arg.retain_symbols_file)
+      sym->write_to_symtab = true;
 
   for (std::string_view arg : ctx.arg.trace_symbol)
     get_symbol(ctx, arg)->is_traced = true;
@@ -610,7 +610,8 @@ int mold_main(int argc, char **argv) {
   ctx.verneed->construct(ctx);
 
   // Compute .symtab and .strtab sizes for each file.
-  create_output_symtab(ctx);
+  if (!ctx.arg.strip_all)
+    create_output_symtab(ctx);
 
   // .eh_frame is a special section from the linker's point of view,
   // as its contents are parsed and reconstructed by the linker,
diff --git a/elf/mold.h b/elf/mold.h
index a4a3bab2d8..dc0f7cd9a6 100644
--- a/elf/mold.h
+++ b/elf/mold.h
@@ -1990,7 +1990,7 @@ struct Context {
     std::string soname;
     std::string sysroot;
     std::string_view emulation;
-    std::unique_ptr<std::unordered_set<std::string_view>> retain_symbols_file;
+    std::optional<std::vector<Symbol<E> *>> retain_symbols_file;
     std::unordered_map<std::string_view, u64> section_align;
     std::unordered_map<std::string_view, u64> section_start;
     std::unordered_set<std::string_view> ignore_ir_file;
diff --git a/elf/output-chunks.cc b/elf/output-chunks.cc
index 95c111619c..03bc4b0d74 100644
--- a/elf/output-chunks.cc
+++ b/elf/output-chunks.cc
@@ -477,7 +477,7 @@ void StrtabSection<E>::update_shdr(Context<E> &ctx) {
   // affect correctness of the program but helps disassembler to
   // disassemble machine code appropriately.
   if constexpr (is_arm32<E>)
-    if (!ctx.arg.strip_all && !ctx.arg.retain_symbols_file)
+    if (!ctx.arg.strip_all)
       offset += sizeof("$a\0$t\0$d");
 
   for (Chunk<E> *chunk : ctx.chunks) {
@@ -504,7 +504,7 @@ void StrtabSection<E>::copy_buf(Context<E> &ctx) {
   buf[0] = '\0';
 
   if constexpr (is_arm32<E>)
-    if (!ctx.arg.strip_all && !ctx.arg.retain_symbols_file)
+    if (!ctx.arg.strip_all)
       memcpy(buf + 1, "$a\0$t\0$d", 9);
 }
 
diff --git a/elf/passes.cc b/elf/passes.cc
index d9b8bcf7ba..7f215ebe2b 100644
--- a/elf/passes.cc
+++ b/elf/passes.cc
@@ -1744,11 +1744,9 @@ template <typename E>
 void create_output_symtab(Context<E> &ctx) {
   Timer t(ctx, "compute_symtab_size");
 
-  if (!ctx.arg.strip_all && !ctx.arg.retain_symbols_file) {
-    tbb::parallel_for_each(ctx.chunks, [&](Chunk<E> *chunk) {
-      chunk->compute_symtab_size(ctx);
-    });
-  }
+  tbb::parallel_for_each(ctx.chunks, [&](Chunk<E> *chunk) {
+    chunk->compute_symtab_size(ctx);
+  });
 
   tbb::parallel_for_each(ctx.objs, [&](ObjectFile<E> *file) {
     file->compute_symtab_size(ctx);
